<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Go | Hashmal Blog]]></title>
  <link href="http://mikeys.github.com/blog/categories/go/atom.xml" rel="self"/>
  <link href="http://mikeys.github.com/"/>
  <updated>2013-07-16T09:48:08+03:00</updated>
  <id>http://mikeys.github.com/</id>
  <author>
    <name><![CDATA[Miki Shiran]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Understanding Go Slices Behaviour]]></title>
    <link href="http://mikeys.github.com/blog/2013/07/15/understanding-go-slices/"/>
    <updated>2013-07-15T22:35:00+03:00</updated>
    <id>http://mikeys.github.com/blog/2013/07/15/understanding-go-slices</id>
    <content type="html"><![CDATA[<p>During my initial steps learning the Go language,
familiar with pointers, I ran into some difficulties grasping why do "reference types" (as the <a href="http://golang.org/ref/spec#Making_slices_maps_and_channel">golang official docs</a>
 as well as other Go resources, actually call them) behave the way they do, and how do they really look like under the hood, as the name "reference types" confuses a bit.</p>

<p>Searching through the web, I came across this <a href="https://groups.google.com/forum/#!msg/golang-nuts/xQUsmdo6oSs/RJ8SF4NsbowJ">'golang-nuts' forum thread</a> which cleared it all up for me
and hopefully I'll be able to summarize the good parts in this post.</p>

<p>Also note, that although this post focuses on Slices- Maps and Channels
work the same way.</p>

<ul>
<li>You may think of slices as a struct with the following 3 fields:

<ul>
<li>array (holds a pointer to an array)</li>
<li>len (holds the pointed array's length)</li>
<li>cap (holds the pointed array's capacity)</li>
</ul>
</li>
</ul>


<p>In Go, arguments are always passed to functions by value (you can argue with that by saying that you can always pass a pointer to the real instance, but even then:
you're actually passing a <strong>copy</strong> of the original pointer).<br/>
Slices are no different: when passing a slice as an argument, you're actually passing a copy of the struct I described above, to the function.<br/>
The pointer in that 'struct copy' refers to the same array as the original struct, meaning that when you're altering the slice's elements, you're actually altering the pointed array's elements and as a result,
the changes are reflected in the original slice. This part is pretty straightforward.</p>

<p>Now for the more interesting part:<br/>
When you perform operations that alter the struct's fields (as opposed to altering the slice's elements), like expanding the slice using <code>append(slice)</code> (resulting a greater <code>len</code> and sometimes a greater <code>capacity</code>) they will <strong>not</strong> be reflected in the original struct,
the reason is obvious: all you're doing is altering a <strong>copy</strong>.</p>

<p>Hopefully, the following example will better reflect the above:</p>

<p>``` go
package main</p>

<p>import (</p>

<pre><code>"fmt"
</code></pre>

<p>)</p>

<p>func doSomething(slice []int) []int {</p>

<pre><code>fmt.Printf("(pre-append) len: %d\n", len(slice))
fmt.Printf("(pre-append) value: %d\n", slice)

slice[0] = 3
slice[1] = 4

slice = append(slice, 4, 5)

fmt.Printf("(post-append) len: %d\n", len(slice))
fmt.Printf("(post-append) value: %d\n", slice)

return slice
</code></pre>

<p>}</p>

<p>func main() {</p>

<pre><code>fmt.Printf("(pre-doSomething) len: %d\n", len(mySlice))
fmt.Printf("(pre-doSomething) value: %d\n", mySlice)

mySlice := make([]int, 2, 4)
doSomething(mySlice)

fmt.Printf("(post-doSomething) len: %d\n", len(mySlice))
fmt.Printf("(post-doSomething) value: %d\n", mySlice)
</code></pre>

<p>}</p>

<p>// Output:
//  (pre-append) len: 2
//  (pre-append) value: [0 0]
//  (post-append) len: 4
//  (post-append) value: [3 4 4 5]
//  (post-doSomething) len: 2
//  (post-doSomething) value: [3 4]
```</p>
]]></content>
  </entry>
  
</feed>
